# 多线程基础

## 实现方法

### 继承Thread类

- 子类继承Thread类实现多线程能力

- 启动线程 thread.start()
- 不建议使用，避免OOP思想单继承局限性

```java
public class MyThread extends Thread{

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码-- " + i);
        }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("我在学习多线程-- " + i);
        }
    }
}

```

### 实现Runnable 接口

- 实现Runnable接口实现多线程能力
- 启动线程：传入目标对象 + 线程对象.start()
- 建议使用，方便灵活，方便同一对象被多个线程使用

```java
package com.example.demo.thread;

public class MyThread3  implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码--- " + i);
        }
    }


    public static void main(String[] args) {
        MyThread3 myThread3 = new MyThread3();
        Thread thread = new Thread(myThread3); // 新建线程，传入实现Runnable接口的类
        thread.start();


        for (int i = 0; i < 20; i++) {
            System.out.println("我在学习多线程--- " + i);
        }
    }
}

```

## 实现Callable接口

- 实现Callable接口，需要返回值类型
- 重写call方法，需要抛出异常
- 创建目标对象
- 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(3);
- 提交Future<Boolean> result1 = ser.submit(t1);
- 获取结果： r1  = result1.get();
- 关闭服务：ser.shutdownNow();

```java
package com.example.demo.thread.callable;


import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

public class TestCallable implements Callable {

    private String url;
    private String name;

    public TestCallable(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.download(url, name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable("https://gimg2.baidu.com/image_search/src=http%3A%2F%2F2c.zol-img.com.cn%2Fproduct%2F124_500x2000%2F748%2FceZOdKgDAFsq2.jpg&refer=http%3A%2F%2F2c.zol-img.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626965772&t=df35ea855b369003cc0f795cd48fb662", "1.jpg");
        TestCallable t2 = new TestCallable("https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201409%2F08%2F20140908130732_kVXzh.jpeg&refer=http%3A%2F%2Fcdn.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626965772&t=877da1ae73bbe1038b87452122fd3ba9", "2.jpg");
        TestCallable t3 = new TestCallable("https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fblog%2F201306%2F25%2F20130625150506_fiJ2r.jpeg&refer=http%3A%2F%2Fcdn.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626965772&t=a9d59844ec9045ef0c8e1591699b9366", "3.jpg");

        ExecutorService ser = Executors.newFixedThreadPool(3);
        Future<Boolean> r1 = ser.submit(t1);
        Future<Boolean> r2 = ser.submit(t2);
        Future<Boolean> r3 = ser.submit(t3);

        System.out.println("rs1 = " + r1.get());
        System.out.println("rs2 = " + r2.get());
        System.out.println("rs3 = " + r3.get());

        ser.shutdownNow();
    }

}

@Slf4j
class WebDownloader {
    public void download(String url, String fileName) {
        try {
            FileUtils.copyURLToFile(new URL(url), new File(fileName));
            log.info("图片下载成功，图片名称是：{}", fileName);
        } catch (IOException e) {
            e.printStackTrace();
            log.error("下载图片download方法出错");
        }
    }
}
```

